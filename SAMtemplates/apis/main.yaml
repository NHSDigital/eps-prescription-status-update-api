AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: |
  PSU API's and related resources

Parameters:
  StackName:
    Type: String
    Description: The name of the main stack
    Default: none
  
  EnableMutualTLS:
    Type: String
    Description: Whether to use mutual TLS
  
  TruststoreVersion:
    Type: String
    Description: TruststoreVersion
  
  UpdatePrescriptionStatusStateMachineName:
    Type: String
    Description: Name of the UpdatePrescriptionStatus state machine
    Default: none
  
  UpdatePrescriptionStatusStateMachineArn:
    Type: String
    Description: Arn of the UpdatePrescriptionStatus state machine
    Default: none

  LogRetentionInDays:
    Type: Number
    Description: How long to keep logs for.
  
  EnableSplunk:
    Type: String
    Description: Whether to use splunk

Conditions:
  ShouldUseMutualTLS: !Equals
    - true
    - !Ref EnableMutualTLS

Resources:
  GenerateCertificate:
    Type: AWS::CertificateManager::Certificate
    Properties:
      ValidationMethod: DNS
      DomainName: !Join
        - .
        - - !Ref StackName
          - !ImportValue eps-route53-resources:EPS-domain
      DomainValidationOptions:
        - DomainName: !Join
            - .
            - - !Ref StackName
              - !ImportValue eps-route53-resources:EPS-domain
          HostedZoneId: !ImportValue eps-route53-resources:EPS-ZoneID

  RestApiGateway:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub ${StackName}-apigw
      DisableExecuteApiEndpoint: !If
        - ShouldUseMutualTLS
        - true
        - !Ref AWS::NoValue

  RestApiDomain:
    Type: AWS::ApiGateway::DomainName
    Properties:
      DomainName: !Join
        - .
        - - !Ref StackName
          - !ImportValue eps-route53-resources:EPS-domain
      CertificateArn: !Ref GenerateCertificate
      EndpointConfiguration: 
        Types:
          - REGIONAL
      MutualTlsAuthentication:
        TruststoreUri: !If
          - ShouldUseMutualTLS
          - !Join
            - /
            - - s3:/
              - !Select
                - 5
                - !Split
                  - ':'
                  - !ImportValue account-resources:TrustStoreBucket
              - psu-truststore.pem
          - !Ref AWS::NoValue
        TruststoreVersion: !If
          - ShouldUseMutualTLS
          - !Ref TruststoreVersion
          - !Ref AWS::NoValue

  RestApiRecordSet:
    Type: AWS::Route53::RecordSet
    Properties:
      Name: !Join
        - .
        - - !Ref StackName
          - !ImportValue eps-route53-resources:EPS-domain
      Type: A
      HostedZoneId: !ImportValue eps-route53-resources:EPS-ZoneID
      AliasTarget:
        DNSName: !GetAtt RestApiDomain.RegionalDomainName
        HostedZoneId: !GetAtt RestApiDomain.RegionalHostedZoneId

  UpdatePrescriptionStatusMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApiGateway
      ResourceId: !GetAtt RestApiGateway.RootResourceId
      HttpMethod: POST
      Integration:
        Type: AWS
        Credentials: !GetAtt HttpApiGatewayResources.Outputs.ApiGwRoleArn
        IntegrationHttpMethod: POST
        PassthroughBehavior: WHEN_NO_MATCH
        RequestTemplates:
          application/json: !Sub
            - |-
              ## Velocity Template used for API Gateway request mapping template
              ## "@@" is used here as a placeholder for '"' to avoid using escape characters.

              #set($includeHeaders = true)
              #set($includeQueryString = true)
              #set($includePath = true)
              #set($requestContext = '')

              #set($inputString = '')
              #set($allParams = $input.params())
              {
                  "stateMachineArn": "${stateMachineArn}",

                  #set($inputString = "$inputString,@@body@@: $input.body")

                  #if ($includeHeaders)
                      #set($inputString = "$inputString, @@headers@@:{")
                      #foreach($paramName in $allParams.header.keySet())
                          #set($inputString = "$inputString @@$paramName@@: @@$util.escapeJavaScript($allParams.header.get($paramName))@@")
                          #if($foreach.hasNext)
                              #set($inputString = "$inputString,")
                          #end
                      #end
                      #set($inputString = "$inputString }")

                  #end

                  #if ($includeQueryString)
                      #set($inputString = "$inputString, @@querystring@@:{")
                      #foreach($paramName in $allParams.querystring.keySet())
                          #set($inputString = "$inputString @@$paramName@@: @@$util.escapeJavaScript($allParams.querystring.get($paramName))@@")
                          #if($foreach.hasNext)
                              #set($inputString = "$inputString,")
                          #end
                      #end
                      #set($inputString = "$inputString }")
                  #end

                  #if ($includePath)
                      #set($inputString = "$inputString, @@path@@:{")
                      #foreach($paramName in $allParams.path.keySet())
                          #set($inputString = "$inputString @@$paramName@@: @@$util.escapeJavaScript($allParams.path.get($paramName))@@")
                          #if($foreach.hasNext)
                              #set($inputString = "$inputString,")
                          #end
                      #end
                      #set($inputString = "$inputString }")
                  #end

                  ## Check if the request context should be included as part of the execution input
                  #if($requestContext && !$requestContext.empty)
                      #set($inputString = "$inputString,")
                      #set($inputString = "$inputString @@requestContext@@: $requestContext")
                  #end

                  #set($inputString = "$inputString}")
                  #set($inputString = $inputString.replaceAll("@@",'"'))
                  #set($len = $inputString.length() - 1)
                  "input": "{$util.escapeJavaScript($inputString.substring(1,$len))}"
              }
            - stateMachineArn: !Ref UpdatePrescriptionStatusStateMachineArn
        IntegrationResponses:
          - StatusCode: 200
            ResponseTemplates:
              application/json: |-
                #set($payload = $util.parseJson($input.path('$.output')))
                #set($context.responseOverride.status = $payload.Payload.statusCode)
                #set($allHeaders = $payload.Payload.headers)

                #foreach($headerName in $allHeaders.keySet())
                    #set($context.responseOverride.header[$headerName] = $allHeaders.get($headerName))
                #end

                $payload.Payload.body

  RestApiGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    Properties:
      RestApiId: !Ref RestApiGateway
      StageName: prod

  RestApiGatewayStage:
    Type: AWS::ApiGateway::Stage
    Properties:
      RestApiId: !Ref RestApiGateway
      StageName: prod
      DeploymentId: !Ref RestApiGatewayDeployment
      AccessLogSetting:
        DestinationArn: !GetAtt HttpApiGatewayResources.Outputs.ApiGwAccessLogsArn
        Format: '{ "requestTime": "$context.requestTime", "apiId": "$context.apiId", "accountId": "$context.accountId", "resourcePath": "$context.resourcePath", "stage": "$context.stage", "requestId": "$context.requestId", "extendedRequestId": "$context.extendedRequestId", "status": "$context.status", "httpMethod": "$context.httpMethod", "protocol": "$context.protocol", "path": "$context.path", "responseLatency": "$context.responseLatency", "responseLength": "$context.responseLength", "domainName": "$context.domainName", "identity": { "sourceIp": "$context.identity.sourceIp", "userAgent": "$context.identity.userAgent", "clientCert":{ "subjectDN": "$context.identity.clientCert.subjectDN", "issuerDN": "$context.identity.clientCert.issuerDN", "serialNumber": "$context.identity.clientCert.serialNumber", "validityNotBefore": "$context.identity.clientCert.validity.notBefore", "validityNotAfter": "$context.identity.clientCert.validity.notAfter" }}, "integration":{ "error": "$context.integration.error", "integrationStatus": "$context.integration.integrationStatus", "latency": "$context.integration.latency", "requestId": "$context.integration.requestId", "status": "$context.integration.status" }}'
  
  HttpApiGatewayResources:
    Type: AWS::Serverless::Application
    Properties:
      Location: api_resources.yaml
      Parameters:
        AdditionalPolicies: !Join
          - ','
          - - Fn::ImportValue: !Sub ${StackName}:state-machines:${UpdatePrescriptionStatusStateMachineName}:ExecuteStateMachinePolicy
        ApiName: !Sub ${StackName}-apigw
        LogRetentionInDays: !Ref LogRetentionInDays
        EnableSplunk: !Ref EnableSplunk
