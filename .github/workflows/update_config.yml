name: Update Application Configuration Parameters

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment to update App Config parameters'
        required: true
        type: choice
        options:
          - dev
          - ref
          - qa
          - int
          - prod
      stack_name:
        description: 'Environment / stack target (defaults to environment)'
        required: false
        type: string
      dry_run:
        description: 'Dry run mode (plan only, no changes made)'
        required: false
        type: boolean
        default: false
      scheduled_time:
        description: 'Execution time (UTC) - YYYY-MM-DD HH:MM or HH:MM for today (leave empty to execute immediately)'
        required: false
        type: string

permissions:
  id-token: write
  contents: read

jobs:
  update_ssm_parameters:
    runs-on: ubuntu-22.04
    environment: ${{ inputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Wait for scheduled time
        if: inputs.scheduled_time != ''
        run: |
          SCHEDULED_TIME="${{ inputs.scheduled_time }}"
          CURRENT_TIME=$(date -u +"%Y-%m-%d %H:%M:%S")

          echo "## ⏰ Scheduled Execution" >> "$GITHUB_STEP_SUMMARY"
          echo "Current time (UTC): ${CURRENT_TIME}" >> "$GITHUB_STEP_SUMMARY"
          echo "Scheduled time (UTC): ${SCHEDULED_TIME}" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          # Parse scheduled time - support both "YYYY-MM-DD HH:MM" and "HH:MM" formats
          if [[ "$SCHEDULED_TIME" =~ ^[0-9]{1,2}:[0-9]{2}$ ]]; then
            # Time only provided - use today's date
            TODAY=$(date -u +"%Y-%m-%d")
            SCHEDULED_TIME="${TODAY} ${SCHEDULED_TIME}"
            echo "Using today's date: ${SCHEDULED_TIME}" >> "$GITHUB_STEP_SUMMARY"
          fi

          # Convert to epoch timestamps
          SCHEDULED_EPOCH=$(date -u -d "${SCHEDULED_TIME}" +%s 2>/dev/null || date -u -j -f "%Y-%m-%d %H:%M" "${SCHEDULED_TIME}" +%s 2>/dev/null)
          CURRENT_EPOCH=$(date -u +%s)

          if [ -z "$SCHEDULED_EPOCH" ]; then
            echo "❌ Error: Invalid scheduled time format. Use 'YYYY-MM-DD HH:MM' or 'HH:MM'" >> "$GITHUB_STEP_SUMMARY"
            echo "Error: Invalid scheduled time format: ${SCHEDULED_TIME}"
            echo "Expected format: 'YYYY-MM-DD HH:MM' or 'HH:MM' (for today)"
            exit 1
          fi

          WAIT_SECONDS=$((SCHEDULED_EPOCH - CURRENT_EPOCH))

          if [ $WAIT_SECONDS -lt 0 ]; then
            echo "⚠️ Warning: Scheduled time is in the past" >> "$GITHUB_STEP_SUMMARY"
            echo "Proceeding with immediate execution..." >> "$GITHUB_STEP_SUMMARY"
            echo "Warning: Scheduled time ${SCHEDULED_TIME} is in the past. Proceeding immediately."
          elif [ $WAIT_SECONDS -eq 0 ]; then
            echo "✅ Scheduled time is now. Proceeding with execution..." >> "$GITHUB_STEP_SUMMARY"
          else
            WAIT_MINUTES=$((WAIT_SECONDS / 60))
            WAIT_HOURS=$((WAIT_MINUTES / 60))
            REMAINING_MINUTES=$((WAIT_MINUTES % 60))

            echo "⏳ Waiting ${WAIT_HOURS}h ${REMAINING_MINUTES}m (${WAIT_SECONDS} seconds) until scheduled time..." >> "$GITHUB_STEP_SUMMARY"
            echo "Waiting ${WAIT_HOURS}h ${REMAINING_MINUTES}m until ${SCHEDULED_TIME} UTC..."

            # Display countdown every 15 minutes for long waits
            while [ $WAIT_SECONDS -gt 0 ]; do
              if [ $WAIT_SECONDS -gt 900 ]; then
                # For waits longer than 5 minutes, update every 15 minutes
                sleep 900
                WAIT_SECONDS=$((WAIT_SECONDS - 900))
                REMAINING_MINUTES=$((WAIT_SECONDS / 60))
                echo "⏳ ${REMAINING_MINUTES} minutes remaining until ${SCHEDULED_TIME} UTC..."
              else
                # For the last 15 minutes, just wait
                sleep $WAIT_SECONDS
                WAIT_SECONDS=0
              fi
            done

            echo "✅ Scheduled time reached. Proceeding with execution..." >> "$GITHUB_STEP_SUMMARY"
            echo "Scheduled time reached. Starting SSM parameter updates..."
          fi
          echo "" >> "$GITHUB_STEP_SUMMARY"

      - name: Set stack name
        id: stack_config
        run: |
          if [ -n "${{ inputs.stack_name }}" ]; then
            STACK_NAME="${{ inputs.stack_name }}"
          else
            # Default stack names per environment
            case "${{ inputs.environment }}" in
              dev)
                STACK_NAME="psu"
                ;;
              ref)
                STACK_NAME="psu-ref"
                ;;
              qa)
                STACK_NAME="psu-qa"
                ;;
              int)
                STACK_NAME="psu-int"
                ;;
              prod)
                STACK_NAME="psu-prod"
                ;;
              *)
                echo "Unknown environment: ${{ inputs.environment }}"
                exit 1
                ;;
            esac
          fi
          echo "stack_name=${STACK_NAME}" >> "$GITHUB_OUTPUT"
          echo "## Updating SSM Parameters for Environment: ${{ inputs.environment }}" >> "$GITHUB_STEP_SUMMARY"
          echo "**Stack Name:** ${STACK_NAME}" >> "$GITHUB_STEP_SUMMARY"
          if [ "${{ inputs.dry_run }}" = "true" ]; then
            echo "**Mode:** Dry Run (no changes will be made)" >> "$GITHUB_STEP_SUMMARY"
          fi
          if [ "${{ inputs.scheduled_time }}" != "" ]]; then
            echo "**Scheduled Time:** ${{ inputs.scheduled_time }} UTC" >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: eu-west-2
          role-to-assume: ${{ secrets.APP_CONFIG_ROLE }}
          role-session-name: psu-update-ssm-parameters

      - name: Process and update SSM parameters
        env:
          STACK_NAME: ${{ steps.stack_config.outputs.stack_name }}
          ENVIRONMENT: ${{ inputs.environment }}
          DRY_RUN: ${{ inputs.dry_run }}
        run: |
          set -e

          echo "Processing SSM parameters for environment: ${ENVIRONMENT}"
          echo ""

          # Read the configuration file
          CONFIG_FILE="ssm-parameters-config.json"

          if [ ! -f "${CONFIG_FILE}" ]; then
            echo "Error: Configuration file ${CONFIG_FILE} not found"
            exit 1
          fi

          # Get list of parameters
          PARAM_NAMES=$(jq -r '.parameters | keys[]' "${CONFIG_FILE}")

          echo "### Parameter Updates" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          # Process each parameter
          for PARAM_NAME in ${PARAM_NAMES}; do
            echo "----------------------------------------"
            echo "Processing parameter: ${PARAM_NAME}"

            # Get production values as array
            PROD_VALUES=$(jq -r ".parameters.\"${PARAM_NAME}\".prod[]?" "${CONFIG_FILE}")

            # Get environment-specific values as array
            ENV_VALUES=$(jq -r ".parameters.\"${PARAM_NAME}\".\"${ENVIRONMENT}\"[]?" "${CONFIG_FILE}")

            # Combine values: production first, then environment-specific additions
            ALL_VALUES=""
            if [ -n "${PROD_VALUES}" ]; then
              ALL_VALUES="${PROD_VALUES}"
            fi

            if [ -n "${ENV_VALUES}" ]; then
              if [ -n "${ALL_VALUES}" ]; then
                ALL_VALUES="${ALL_VALUES}"$'\n'"${ENV_VALUES}"
              else
                ALL_VALUES="${ENV_VALUES}"
              fi
            fi

            # Deduplicate while preserving order (first occurrence wins)
            # Production values take precedence since they appear first
            # This handles cases where admins accidentally include prod values in env-specific arrays
            if [ -n "${ALL_VALUES}" ]; then
              # Remove empty lines, deduplicate using awk (keeps first occurrence), convert to comma-separated
              COMMA_SEPARATED=$(echo "${ALL_VALUES}" | grep -v '^$' | awk '!seen[$0]++' | paste -sd ',' -)
            else
              COMMA_SEPARATED=""
            fi

            # SSM Parameter name
            SSM_PARAM_NAME="${STACK_NAME}-${PARAM_NAME}"

            echo "Parameter Name: ${SSM_PARAM_NAME}"
            echo "New Value: ${COMMA_SEPARATED}"

            # Add to summary
            echo "#### ${PARAM_NAME}" >> "$GITHUB_STEP_SUMMARY"
            echo "- **SSM Parameter:** \`${SSM_PARAM_NAME}\`" >> "$GITHUB_STEP_SUMMARY"
            echo "- **New Value:** \`${COMMA_SEPARATED}\`" >> "$GITHUB_STEP_SUMMARY"

            # Check if parameter exists and get current value
            if aws ssm get-parameter --name "${SSM_PARAM_NAME}" --region eu-west-2 >/dev/null 2>&1; then
              CURRENT_VALUE=$(aws ssm get-parameter --name "${SSM_PARAM_NAME}" --region eu-west-2 --query 'Parameter.Value' --output text)
              echo "Current Value: ${CURRENT_VALUE}"
              echo "- **Current Value:** \`${CURRENT_VALUE}\`" >> "$GITHUB_STEP_SUMMARY"

              if [ "${CURRENT_VALUE}" = "${COMMA_SEPARATED}" ]; then
                echo "✓ No change needed (values are identical)"
                echo "- **Status:** ✅ No change needed" >> "$GITHUB_STEP_SUMMARY"
              else
                if [ "${DRY_RUN}" = "true" ]; then
                  echo "⚠ DRY RUN: Would update parameter"
                  echo "- **Status:** ⚠️ Would be updated (dry run)" >> "$GITHUB_STEP_SUMMARY"
                else
                  echo "Updating parameter..."
                  aws ssm put-parameter \
                    --name "${SSM_PARAM_NAME}" \
                    --value "${COMMA_SEPARATED}" \
                    --type String \
                    --overwrite \
                    --region eu-west-2
                  echo "✓ Parameter updated successfully"
                  echo "- **Status:** ✅ Updated successfully" >> "$GITHUB_STEP_SUMMARY"
                fi
              fi
            else
              echo "⚠ Warning: Parameter does not exist: ${SSM_PARAM_NAME}"
              echo "- **Status:** ⚠️ Parameter does not exist (cannot create, must exist in stack)" >> "$GITHUB_STEP_SUMMARY"

              if [ "${DRY_RUN}" != "true" ]; then
                echo "Note: This workflow only updates existing SSM parameters created by CloudFormation."
                echo "The parameter should be defined in SAMtemplates/parameters/main.yaml"
              fi
            fi

            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo ""
          done

          echo "----------------------------------------"
          echo "SSM parameter update process completed"

          if [ "${DRY_RUN}" = "true" ]; then
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "---" >> "$GITHUB_STEP_SUMMARY"
            echo "**Note:** This was a dry run. No changes were made to AWS." >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Verify parameters
        if: inputs.dry_run == false
        env:
          STACK_NAME: ${{ steps.stack_config.outputs.stack_name }}
          ENVIRONMENT: ${{ inputs.environment }}
        run: |
          echo ""
          echo "========================================="
          echo "Verification: Reading back all parameters"
          echo "========================================="
          echo ""

          CONFIG_FILE=".github/ssm-parameters-config.json"
          PARAM_NAMES=$(jq -r '.parameters | keys[]' "${CONFIG_FILE}")

          echo "### Verification Results" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          for PARAM_NAME in ${PARAM_NAMES}; do
            SSM_PARAM_NAME="${STACK_NAME}-${PARAM_NAME}"

            if VALUE=$(aws ssm get-parameter --name "${SSM_PARAM_NAME}" --region eu-west-2 --query 'Parameter.Value' --output text 2>/dev/null); then
              echo "${PARAM_NAME}: ${VALUE}"
              echo "- **${PARAM_NAME}:** \`${VALUE}\`" >> "$GITHUB_STEP_SUMMARY"
            else
              echo "${PARAM_NAME}: [Parameter not found]"
              echo "- **${PARAM_NAME}:** ⚠️ Not found" >> "$GITHUB_STEP_SUMMARY"
            fi
          done
